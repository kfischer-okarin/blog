#+AUTHOR: Kevin Fischer
#+TITLE: KF Labo Blog
#+DESCRIPTION: Articles about Game Dev, TDD, maintainable software and possibly other random stuff I'm interested in.

#+STARTUP: overview
#+STARTUP: inlineimages
#+STARTUP: fninline
#+PROPERTY: header-args:mermaid :theme dark
#+PROPERTY: header-args:mermaid+ :file (kf-mermaid-result-filename)
#+PROPERTY: header-args:mermaid+ :exports results


* Capturing all my git commits with org mode
  :PROPERTIES:
  :END:

** Why log my commits?
   I often struggle with remembering what kind of things I worked on exactly during a work day and how much time I spent
   on them. I tried dozens of clocking applications but in the end they all rely on my own disciplined ability to turn
   the clock on at the right time and switch the clocked task when I start working on something else.

   So I guess the best way to remember what I did would be to automatically log all kinds of little things I do at the
   computer so I can use that data as landmarks when I look back on the day.

   One main activity I do during my development day time job (and during lots of my free time coding) is committing to a
   repository so that seems like a good place to start.

** Mechanism overview
   #+begin_src mermaid
     flowchart LR
       Hook-->Test
   #+end_src


* It starts with an @
  :PROPERTIES:
  :POST_ID: it_starts_with_an_at
  :SERIES: CyberpunkRL
  :PUBLISHED_AT: [2024-02-15 Thu 23:21]
  :END:
  Today I participated in a so called /mokumoku-kai/ (もくもく会) for the first time - a Japanese style of meetup where
  people just come together to silently[fn::/mokumoku/ meaning silent] work on their own projects. Basically being
  motivated to work on something by seeing other people busy working.

  Each meeting is probably slightly different but basically it consists of three steps:
  1. Announce what you are planning do to during the meeting
  2. Do the work
  3. Share your progress and your impressions with your group

  I used the opportunity to start yet another roguelike and hopefully stick with it - and as usual it starts with an at
  sign moving over the screen.

  [[file:videos/cyberpunk-rl-0001-at-sign-moving.mp4][An at sign moving over the screen]]

  And with DragonRuby that is just as simple as

  #+begin_src ruby
    def tick(args)
      player_position = args.state.player_position ||= { x: 20, y: 12 }

      keyboard = args.inputs.keyboard
      if keyboard.key_down.up
        player_position[:y] += 1
      elsif keyboard.key_down.down
        player_position[:y] -= 1
      elsif keyboard.key_down.left
        player_position[:x] -= 1
      elsif keyboard.key_down.right
        player_position[:x] += 1
      end

      args.outputs.background_color = [0, 0, 0]
      args.outputs.sprites << {
        x: player_position[:x] * 32, y: player_position[:y] * 32, w: 32, h: 32,
        path: 'sprites/zilk-16x16.png',
        source_x: 0 * 16, source_y: 11 * 16, source_w: 16, source_h: 16
      }
    end
  #+end_src


* My own four walls
  :PROPERTIES:
  :SERIES: CyberpunkRL
  :END:
  Last week I finished with an at sign walking across the screen. That is already a nice start and the next thing I'd
  wanted to do was adding some walls to restrict the player's movement as well as a door which can be opened and closed
  via button press.

** Separating input and execution
   In order to implement walls I will need to check whether I can actually move in the direction I pressed before
   executing the movement.

   Since the current, very simple first version of my movement code immediately and directly updates the player's
   position when an arrow key is pressed, naively adding such a check to each of the four directions would introduce
   unwelcome duplication into my input handling code. Because the movement check is probably something that is going to
   evolve quite a bit as the game becomes more complex, duplication would definitely mean that this would be harder to
   change.

   One thing I do usually very early when creating a game is separating the game logic from the input parsing - by
   transforming the input values into an intermediate data structure, which I like to call *Input Action*. And in this
   case it would naturally help us the aforementioned duplication.

   For now I'll be going with a simple hash (which are really cheap to create in DragonRuby) containing a ~:type~ key
   which specifies the type of input action together with other action specific parameters.

   In my game's case that would look like this for the movement:

   #+begin_src ruby
     player_action = {}
     keyboard = args.inputs.keyboard
     if keyboard.key_down.up
       player_action = { type: :move, direction: { x:  0, y:  1 } }
     elsif keyboard.key_down.down
       player_action = { type: :move, direction: { x:  0, y: -1 } }
     elsif keyboard.key_down.left
       player_action = { type: :move, direction: { x: -1, y:  0 } }
     elsif keyboard.key_down.right
       player_action = { type: :move, direction: { x:  1, y:  0 } }
     end
   #+end_src

   And later in the tick when handling the player input action we can use a simple case statement like this:

   #+begin_src ruby
     case player_action[:type]
     when :move
       player_position[:x] += player_action[:direction][:x]
       player_position[:y] += player_action[:direction][:y]
     end
   #+end_src

   We can easily add the check here, but first let's create some walls.

** Creating a map data structure
   We will need a data structure where we specify which map cells contain walls.

   For now let's keep it simple and stupid and just create a nested array:

   #+begin_src ruby
     # Somewhere at the beginning of the tick
     args.state.current_map ||= 40.times.map { 22.times.map { {} } }
   #+end_src

   This will give us a 40 by 22 array filled with empty hashes (I like to arrange two dimensional arrays by columns so
   that I can access them intuitively via ~array[x][y]~).

** Adding a reset hotkey

** Refactoring the sprite rendering

** DragonRuby hot reload trick - selectively resetting state

** A good tricks works twice - authoring the map with hot reload

** Doing collisions

** A door (?)

** Interacting with the door

** A Video

   [[file:videos/cyberpunk-rl-0002-walls-and-a-door.mp4][Leaving the room]]


* File Settings                                                    :noexport:
  Local Variables:
  org-adapt-indentation: t
  eval: (load (expand-file-name "src/articles.el" (file-name-directory (buffer-file-name))))
  End:
