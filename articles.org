#+STARTUP: overview
#+STARTUP: inlineimages
#+STARTUP: fninline
#+PROPERTY: header-args:mermaid :theme dark
#+PROPERTY: header-args:mermaid+ :file (kf-mermaid-result-filename)
#+PROPERTY: header-args:mermaid+ :exports results

* Capturing all my git commits with org mode
  :PROPERTIES:
  :END:

** Why log my commits?
   I often struggle with remembering what kind of things I worked on exactly during a work day and how much time I spent
   on them. I tried dozens of clocking applications but in the end they all rely on my own disciplined ability to turn
   the clock on at the right time and switch the clocked task when I start working on something else.

   So I guess the best way to remember what I did would be to automatically log all kinds of little things I do at the
   computer so I can use that data as landmarks when I look back on the day.

   One main activity I do during my development day time job (and during lots of my free time coding) is committing to a
   repository so that seems like a good place to start.

** Mechanism overview
   #+begin_src mermaid
     flowchart LR
       Hook-->Test
   #+end_src


* It starts with an @
  :PROPERTIES:
  :POST_ID: it_starts_with_an_at
  :SERIES: CyberpunkRL
  :PUBLISHED_AT: [2024-02-15 Thu 23:21]
  :END:
  Today I participated in a so called /mokumoku-kai/ (もくもく会) for the first time - a Japanese style of meetup where
  people just come together to silently[fn::/mokumoku/ meaning silent] work on their own projects. Basically being
  motivated to work on something by seeing other people busy working.

  Each meeting is probably slightly different but basically it consists of three steps:
  1. Announce what you are planning do to during the meeting
  2. Do the work
  3. Share your progress and your impressions with your group

  I used the opportunity to start yet another roguelike and hopefully stick with it - and as usual it starts with an at
  sign moving over the screen.

  [[file:videos/cyberpunk-rl-0001-at-sign-moving.mp4][An at sign moving over the screen]]

  And with DragonRuby that is just as simple as

  #+begin_src ruby
    def tick(args)
      player_position = args.state.player_position ||= { x: 20, y: 12 }

      keyboard = args.inputs.keyboard
      if keyboard.key_down.up
        player_position[:y] += 1
      elsif keyboard.key_down.down
        player_position[:y] -= 1
      elsif keyboard.key_down.left
        player_position[:x] -= 1
      elsif keyboard.key_down.right
        player_position[:x] += 1
      end

      args.outputs.background_color = [0, 0, 0]
      args.outputs.sprites << {
        x: player_position[:x] * 32, y: player_position[:y] * 32, w: 32, h: 32,
        path: 'sprites/zilk-16x16.png',
        source_x: 0 * 16, source_y: 11 * 16, source_w: 16, source_h: 16
      }
    end
  #+end_src


* My own four walls
  :PROPERTIES:
  :SERIES_ID: CyberpunkRL
  :END:
  Last week I left off with having an at sign walking across the screen. That is already a nice start and the next
  logical step would be to add some walls to restrict the player's movement as well as a door which can be opened and
  closed via a button press.

** Separating the player's action and their execution
   In order to implement walls I will need check whether I can actually move in the direction I pressed.

   Since the current, very simple first version of my movement code immediately and directly updates the player's
   position when an arrow key is pressed, adding such a check would

** Adding a reset hotkey

** Refactoring the sprite rendering

** DragonRuby hot reload trick - selectively resetting state

** A good tricks works twice - authoring the map with hot reload

** Doing collisions

** A door (?)

** Interacting with the door

** A Video

   [[file:videos/cyberpunk-rl-0002-walls-and-a-door][Leaving the room]]

* File Settings                                                    :noexport:
  Local Variables:
  org-adapt-indentation: t
  eval: (load (expand-file-name "src/articles.el" (file-name-directory (buffer-file-name))))
  End:
